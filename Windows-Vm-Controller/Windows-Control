pipeline {
    agent any

    environment {
        AWS_ACCESS_KEY_ID = credentials('AWS_ACCESS_KEY_ID')
        AWS_SECRET_ACCESS_KEY = credentials('AWS_SECRET_ACCESS_KEY')
        TF_STATE_BUCKET = "my-terraform-state-bucket-425"
        TF_STATE_KEY = "terraform.tfstate"
        S3_SCRIPT_PATH = "s3://my-terraform-state-bucket-425"
        ADMIN_USERNAME = "Administrator"
        GIT_BASH = "C:\\Program Files\\Git\\bin\\bash.exe"
    }

    stages {
          stage('Get Windows Instance IPs from Terraform State') {
            steps {
                script {
                    // Fetch latest Terraform state file from S3
                    bat "\"${GIT_BASH}\" -c 'AWS_ACCESS_KEY_ID=${env.AWS_ACCESS_KEY_ID} AWS_SECRET_ACCESS_KEY=${env.AWS_SECRET_ACCESS_KEY} aws s3 cp s3://${TF_STATE_BUCKET}/${TF_STATE_KEY} terraform.tfstate'"

                    // Extract only Windows VM public IPs from Terraform state
                    def windowsIPs = powershell(returnStdout: true, script: """
                        \$tfState = Get-Content terraform.tfstate -Raw | ConvertFrom-Json
                        \$windowsIPs = \$tfState.resources | Where-Object { \$_.'type' -eq 'aws_instance' -and \$_.'name' -match 'windows' } | 
                            ForEach-Object { \$_.'instances' } | ForEach-Object { \$_[0].'attributes'.'public_ip' }
                        \$windowsIPs -join ','
                    """).trim()

                    if (!windowsIPs) {
                        error("ERROR: No Windows VM IPs found in Terraform state!")
                    }

                    echo "Windows VM IPs: ${windowsIPs}"

                    // Store IPs as an environment variable
                    env.WINDOWS_IPS = windowsIPs
                }
            }
        }

        stage('Download Scripts from S3') {
            steps {
                script {
                    echo "Downloading scripts from S3..."

                    bat "\"C:\\Program Files\\Git\\bin\\bash.exe\" -c 'AWS_ACCESS_KEY_ID=${AWS_ACCESS_KEY_ID} AWS_SECRET_ACCESS_KEY=${AWS_SECRET_ACCESS_KEY} aws s3 cp ${S3_SCRIPT_PATH}/ConfigureRemotingForAnsible.ps1 ./'"
                    bat "\"C:\\Program Files\\Git\\bin\\bash.exe\" -c 'AWS_ACCESS_KEY_ID=${AWS_ACCESS_KEY_ID} AWS_SECRET_ACCESS_KEY=${AWS_SECRET_ACCESS_KEY} aws s3 cp ${S3_SCRIPT_PATH}/Create_user.ps1 ./'"
                    
                    echo "Scripts downloaded successfully!"
                }
            }
        }

        stage('Decrypt Windows Passwords') {
                    steps {
                        script {
                            withCredentials([file(credentialsId: 'windows-private-key', variable: 'PRIVATE_KEY_PATH')]) {
                                if (!env.WINDOWS_IPS?.trim()) {
                                    error "ERROR: No Windows VM IPs found in Terraform state!"
                                }

                                def ipList = env.WINDOWS_IPS.split(',').findAll { it?.trim() } // Removes null/empty IPs
                                def passwords = [:]

                                for (ip in ipList) {
                                    echo "Decrypting password for ${ip}..."

                                    def instanceId = powershell(returnStdout: true, script: """
                                        aws ec2 describe-instances --filters "Name=ip-address,Values=${ip}" --query "Reservations[*].Instances[*].InstanceId" --output text --region us-east-1
                                    """).trim()

                                    if (!instanceId) {
                                        error "ERROR: Instance ID not found for IP ${ip}"
                                    }

                                    def encryptedPassword = powershell(returnStdout: true, script: """
                                        aws ec2 get-password-data --instance-id "${instanceId}" --query 'PasswordData' --output text --region us-east-1
                                    """).trim()

                                    if (!encryptedPassword || encryptedPassword == "None") {
                                        error "ERROR: Encrypted password not found for ${ip}"
                                    }

                                    def decryptedPassword = powershell(returnStdout: true, script: """
                                        \$opensslPath = "C:\\OpenSSL-Win64\\bin\\openssl.exe"
                                        \$privateKeyPath = "${PRIVATE_KEY_PATH}"
                                        \$encryptedPassword = "${encryptedPassword}"

                                        \$decryptedPassword = echo \$encryptedPassword | & \$opensslPath base64 -d -A | & \$opensslPath pkeyutl -decrypt -inkey \$privateKeyPath
                                        Write-Output \$decryptedPassword
                                    """).trim()

                                    if (!decryptedPassword) {
                                        error "ERROR: Failed to decrypt password for ${ip}"
                                    }

                                    passwords[ip] = decryptedPassword
                                }

                                if (passwords.isEmpty()) {
                                    error "ERROR: No passwords were decrypted!"
                                }

                                env.WINDOWS_PASSWORDS = passwords.collect { key, value -> "${key}:${value}" }.join(',')
                            }
                        }
                    }
        }



        stage('Execute Scripts on Windows VMs') {
            steps {
                script {
                    if (!env.WINDOWS_IPS?.trim()) {
                        error "ERROR: No Windows VM IPs available!"
                    }

                    if (!env.WINDOWS_PASSWORDS?.trim()) {
                        error "ERROR: No passwords available for Windows VMs!"
                    }

                    def ipList = env.WINDOWS_IPS.split(',').findAll { it?.trim() } // Removes null/empty IPs
                    def passwordMap = env.WINDOWS_PASSWORDS.split(',').collectEntries { entry ->
                        def parts = entry.split(':')
                        if (parts.size() == 2) {
                            [(parts[0]): parts[1]]
                        } else {
                            [:] // Ignore invalid entries
                        }
                    }

                    for (ip in ipList) {
                        if (!passwordMap.containsKey(ip)) {
                            echo "WARNING: Password for ${ip} not found! Skipping..."
                            continue
                        }

                        def password = passwordMap[ip]

                        echo "Executing scripts on ${ip} using WinRM..."

                        def result = powershell(returnStatus: true, script: """
                            \$username = '${ADMIN_USERNAME}'
                            \$password = ConvertTo-SecureString '${password}' -AsPlainText -Force
                            \$cred = New-Object System.Management.Automation.PSCredential (\$username, \$password)

                            Invoke-Command -ComputerName ${ip} -Credential \$cred -ScriptBlock {
                                Copy-Item -Path .\\ConfigureRemotingForAnsible.ps1 -Destination C:\\Windows\\Temp\\ConfigureRemotingForAnsible.ps1 -Force
                                Copy-Item -Path .\\Create_user.ps1 -Destination C:\\Windows\\Temp\\Create_user.ps1 -Force
                                
                                Write-Output "Executing ConfigureRemotingForAnsible.ps1..."
                                & C:\\Windows\\Temp\\ConfigureRemotingForAnsible.ps1

                                Write-Output "Executing Create_user.ps1..."
                                & C:\\Windows\\Temp\\Create_user.ps1
                            }
                        """)

                        if (result != 0) {
                            error "Execution failed on ${ip}"
                        }

                        echo "Scripts executed successfully on ${ip}!"
                    }
                }
            }
        

                }
            }

            post {
                failure {
                    echo "Pipeline failed! Check logs for details."
                }
            }
        }
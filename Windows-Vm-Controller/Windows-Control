pipeline {
    agent any

    environment {
        AWS_ACCESS_KEY_ID = credentials('AWS_ACCESS_KEY_ID')
        AWS_SECRET_ACCESS_KEY = credentials('AWS_SECRET_ACCESS_KEY')
        TF_STATE_BUCKET = "my-terraform-state-bucket-425"
        TF_STATE_KEY = "terraform.tfstate"
        S3_SCRIPT_PATH = "s3://my-terraform-state-bucket-425"
        ADMIN_USERNAME = "Administrator"
        GIT_BASH = "C:\\Program Files\\Git\\bin\\bash.exe"
        TEMP_POWERSHELL_SCRIPT = "remote_script.ps1"
    }

    stages {
        stage('Get Windows Instance IPs from Terraform State') {
            steps {
                script {
                    bat "\"${GIT_BASH}\" -c 'AWS_ACCESS_KEY_ID=${env.AWS_ACCESS_KEY_ID} AWS_SECRET_ACCESS_KEY=${env.AWS_SECRET_ACCESS_KEY} aws s3 cp s3://${TF_STATE_BUCKET}/${TF_STATE_KEY} terraform.tfstate'"

                    def windowsIPs = powershell(returnStdout: true, script: """
                        \$tfState = Get-Content terraform.tfstate -Raw | ConvertFrom-Json
                        \$windowsIPs = \$tfState.resources | Where-Object { \$_.'type' -eq 'aws_instance' -and \$_.'name' -match 'windows' } | 
                            ForEach-Object { \$_.'instances' } | ForEach-Object { \$_[0].'attributes'.'public_ip' }
                        \$windowsIPs -join ','
                    """).trim()

                    if (!windowsIPs) {
                        error("ERROR: No Windows VM IPs found in Terraform state!")
                    }

                    echo "Windows VM IPs: ${windowsIPs}"
                    env.WINDOWS_IPS = windowsIPs
                }
            }
        }

        stage('Download Scripts from S3') {
            steps {
                script {
                    echo "Downloading scripts from S3..."
                    bat "\"${GIT_BASH}\" -c 'AWS_ACCESS_KEY_ID=${AWS_ACCESS_KEY_ID} AWS_SECRET_ACCESS_KEY=${AWS_SECRET_ACCESS_KEY} aws s3 cp ${S3_SCRIPT_PATH}/ConfigureRemotingForAnsible.ps1 ./'"
                    bat "\"${GIT_BASH}\" -c 'AWS_ACCESS_KEY_ID=${AWS_ACCESS_KEY_ID} AWS_SECRET_ACCESS_KEY=${AWS_SECRET_ACCESS_KEY} aws s3 cp ${S3_SCRIPT_PATH}/Create_user.ps1 ./'"
                    echo "Scripts downloaded successfully!"
                }
            }
        }

        stage('Decrypt Windows Passwords') {
            steps {
                withCredentials([file(credentialsId: 'windows-private-key', variable: 'PRIVATE_KEY_PATH')]) {
                    script {
                        def ipList = env.WINDOWS_IPS?.split(',')?.findAll { it?.trim() } ?: []
                        def passwordEntries = []

                        for (ip in ipList) {
                            echo "Decrypting password for ${ip}..."

                            def instanceId = powershell(returnStdout: true, script: """
                                aws ec2 describe-instances --filters "Name=ip-address,Values=${ip}" --query "Reservations[*].Instances[*].InstanceId" --output text --region us-east-1
                            """).trim()

                            if (!instanceId) {
                                echo "WARNING: Instance ID for ${ip} not found. Skipping..."
                                continue
                            }

                            def decryptedPassword = powershell(returnStdout: true, script: """
                                aws ec2 get-password-data --instance-id ${instanceId} --priv-launch-key ${PRIVATE_KEY_PATH} --query 'PasswordData' --output text --region us-east-1
                            """).trim()

                            if (!decryptedPassword || decryptedPassword == "None") {
                                echo "WARNING: Failed to retrieve decrypted password for ${ip}. Skipping..."
                                continue
                            }

                            passwordEntries.add("${ip}:${decryptedPassword}")
                        }

                        if (passwordEntries.isEmpty()) {
                            error "No passwords were successfully decrypted. Exiting..."
                        }

                        def passwordFile = "${WORKSPACE}\\decrypted_passwords.txt"
                        writeFile file: passwordFile, text: passwordEntries.join('\n')
                        echo "Decryption complete! Passwords stored in ${passwordFile}"
                    }
                }
            }
        }
    

    stage('Execute Scripts on Windows VMs') {
            steps {
                script {
                    def ipList = env.WINDOWS_IPS.split(',').findAll { it?.trim() }
                    def tempPasswordFile = "decrypted_passwords.txt"

                    // Read passwords from the temporary file
                    def passwordMap = [:]
                    if (fileExists(tempPasswordFile)) {
                        def passwordContent = readFile(tempPasswordFile).trim()
                        passwordMap = passwordContent.split('\n').collectEntries { line ->
                            def parts = line.split(':')
                            if (parts.size() == 2) {
                                [(parts[0]): parts[1]]
                            } else {
                                [:]
                            }
                        }
                    }

                    for (ip in ipList) {
                        if (!passwordMap.containsKey(ip)) {
                            echo "WARNING: Password for ${ip} not found! Skipping..."
                            continue
                        }

                        def password = passwordMap[ip]

                        echo "Creating remote PowerShell execution script for ${ip}..."

                        def psScript = """
                        \$username = 'Administrator'
                        \$password = ConvertTo-SecureString '${password}' -AsPlainText -Force
                        \$cred = New-Object System.Management.Automation.PSCredential (\$username, \$password)

                        # Check if WinRM is enabled before creating the session
                        if (!(Test-WSMan -ComputerName ${ip} -Credential \$cred -ErrorAction SilentlyContinue)) {
                            Write-Output "ERROR: WinRM not reachable on ${ip}. Ensure WinRM is enabled."
                            exit 1
                        }

                        # Create WinRM session with authentication options
                        \$sessionOptions = New-PSSessionOption -SkipCACheck -SkipCNCheck -SkipRevocationCheck
                        \$session = New-PSSession -ComputerName ${ip} -Credential \$cred -SessionOption \$sessionOptions

                        if (\$session -eq \$null) {
                            Write-Output "ERROR: Failed to create a session on ${ip}. Skipping..."
                            exit 1
                        }

                        Write-Output "Session created successfully on ${ip}."

                        # Copy scripts to remote VM
                        Write-Output "Copying scripts to ${ip}..."
                        Copy-Item -Path ConfigureRemotingForAnsible.ps1 -Destination C:\\Windows\\Temp\\ConfigureRemotingForAnsible.ps1 -ToSession \$session -Force
                        Copy-Item -Path Create_user.ps1 -Destination C:\\Windows\\Temp\\Create_user.ps1 -ToSession \$session -Force

                        # Ensure execution policy allows script execution
                        Invoke-Command -Session \$session -ScriptBlock {
                            Set-ExecutionPolicy -ExecutionPolicy Bypass -Scope Process -Force
                        }

                        # Execute scripts remotely
                        Invoke-Command -Session \$session -ScriptBlock {
                            Write-Output "Executing ConfigureRemotingForAnsible.ps1..."
                            & C:\\Windows\\Temp\\ConfigureRemotingForAnsible.ps1

                            Write-Output "Executing Create_user.ps1..."
                            & C:\\Windows\\Temp\\Create_user.ps1
                        }

                        # Remove session
                        Remove-PSSession \$session
                        """

                        def scriptPath = "${WORKSPACE}\\execute_remote.ps1"
                        writeFile file: scriptPath, text: psScript

                        echo "Executing script on ${ip} using PowerShell..."
                        def result = bat(returnStatus: true, script: """
                            powershell -File ${scriptPath}
                        """)

                        if (result != 0) {
                            error "Execution failed on ${ip}"
                        }

                        echo "Scripts executed successfully on ${ip}!"
                    }
                }
            }
        }

    }

    post {
        failure {
            echo "Pipeline failed! Check logs for details."
        }
    }
}
pipeline {
    agent any

    environment {
        AWS_ACCESS_KEY_ID = credentials('AWS_ACCESS_KEY_ID')
        AWS_SECRET_ACCESS_KEY = credentials('AWS_SECRET_ACCESS_KEY')
        TF_STATE_BUCKET = "my-terraform-state-bucket-425"
        TF_STATE_KEY = "terraform.tfstate"
        S3_SCRIPT_PATH = "s3://my-terraform-state-bucket-425"
        ADMIN_USERNAME = "Administrator"
        GIT_BASH = "C:\\Program Files\\Git\\bin\\bash.exe"
    }

    stages {
          stage('Get Windows Instance IPs from Terraform State') {
            steps {
                script {
                    // Fetch latest Terraform state file from S3
                    bat "\"${GIT_BASH}\" -c 'AWS_ACCESS_KEY_ID=${env.AWS_ACCESS_KEY_ID} AWS_SECRET_ACCESS_KEY=${env.AWS_SECRET_ACCESS_KEY} aws s3 cp s3://${TF_STATE_BUCKET}/${TF_STATE_KEY} terraform.tfstate'"

                    // Extract only Windows VM public IPs from Terraform state
                    def windowsIPs = powershell(returnStdout: true, script: """
                        \$tfState = Get-Content terraform.tfstate -Raw | ConvertFrom-Json
                        \$windowsIPs = \$tfState.resources | Where-Object { \$_.'type' -eq 'aws_instance' -and \$_.'name' -match 'windows' } | 
                            ForEach-Object { \$_.'instances' } | ForEach-Object { \$_[0].'attributes'.'public_ip' }
                        \$windowsIPs -join ','
                    """).trim()

                    if (!windowsIPs) {
                        error("ERROR: No Windows VM IPs found in Terraform state!")
                    }

                    echo "Windows VM IPs: ${windowsIPs}"

                    // Store IPs as an environment variable
                    env.WINDOWS_IPS = windowsIPs
                }
            }
        }

        stage('Download Scripts from S3') {
            steps {
                script {
                    echo "Downloading scripts from S3..."

                    bat "\"C:\\Program Files\\Git\\bin\\bash.exe\" -c 'AWS_ACCESS_KEY_ID=${AWS_ACCESS_KEY_ID} AWS_SECRET_ACCESS_KEY=${AWS_SECRET_ACCESS_KEY} aws s3 cp ${S3_SCRIPT_PATH}/ConfigureRemotingForAnsible.ps1 ./'"
                    bat "\"C:\\Program Files\\Git\\bin\\bash.exe\" -c 'AWS_ACCESS_KEY_ID=${AWS_ACCESS_KEY_ID} AWS_SECRET_ACCESS_KEY=${AWS_SECRET_ACCESS_KEY} aws s3 cp ${S3_SCRIPT_PATH}/Create_user.ps1 ./'"
                    
                    echo "Scripts downloaded successfully!"
                }
            }
        }

stage('Decrypt Windows Passwords') {
    steps {
        script {
            def ipList = env.WINDOWS_IPS?.split(',')?.findAll { it?.trim() } ?: []
            def passwordEntries = []

            // Define private key file path directly
            def privateKeyFile = "C:\\Ansible-Keys\\terraformkeypair.pem"

            for (ip in ipList) {
                echo "Decrypting password for ${ip}..."

                // Fetch instance ID based on IP
                def instanceId = powershell(returnStdout: true, script: """
                    aws ec2 describe-instances --filters "Name=ip-address,Values=${ip}" --query "Reservations[*].Instances[*].InstanceId" --output text --region us-east-1
                """).trim()

                if (!instanceId) {
                    echo "WARNING: Instance ID for ${ip} not found. Skipping..."
                    continue
                }

                // Run AWS command to get decrypted password
                def decryptedPassword = powershell(returnStdout: true, script: """
                    aws ec2 get-password-data --instance-id ${instanceId} --priv-launch-key ${privateKeyFile} 
                    # --query 'PasswordData' --output text --region us-east-1
                """).trim()

                if (!decryptedPassword || decryptedPassword == "None") {
                    echo "WARNING: Failed to retrieve decrypted password for ${ip}. Skipping..."
                    continue
                }

                passwordEntries.add("${ip}:${decryptedPassword}")
            }

            if (passwordEntries.isEmpty()) {
                error "No passwords were successfully decrypted. Exiting..."
            }

            // Store decrypted passwords in a temporary file
            def passwordFile = "${WORKSPACE}\\decrypted_passwords.txt"
            writeFile file: passwordFile, text: passwordEntries.join('\n')

            echo "Decryption complete! Passwords stored in ${passwordFile}"
        }
    }
}




stage('Enable WinRM & Configure TrustedHosts') {
    steps {
        script {
            def ipList = env.WINDOWS_IPS?.split(',')?.findAll { it?.trim() } ?: []
            def passwordFile = "${WORKSPACE}\\decrypted_passwords.txt"

            // Read passwords from file (avoiding serialization issues)
            def passwordMap = [:]
            def passwordLines = readFile(passwordFile).split('\n')
            passwordLines.each { line ->
                def parts = line.split(':', 2)
                if (parts.size() == 2) {
                    passwordMap[parts[0]] = parts[1]
                }
            }

            for (ip in ipList) {
                echo "Enabling WinRM & Configuring TrustedHosts on ${ip}..."

                def password = passwordMap[ip]
                if (!password) {
                    error "Password for ${ip} not found!"
                }

                def result = powershell(returnStatus: true, script: """
                    \$SecurePassword = ConvertTo-SecureString '${password}' -AsPlainText -Force
                    \$Cred = New-Object System.Management.Automation.PSCredential('${ADMIN_USERNAME}', \$SecurePassword)

                    Invoke-Command -ComputerName ${ip} -Credential \$Cred -ScriptBlock {
                        # Ensure WinRM is fully enabled
                        winrm quickconfig -quiet
                        Enable-PSRemoting -Force
                        winrm set winrm/config/service/Auth '@{Basic="true"}'
                        winrm set winrm/config/client '@{TrustedHosts="*"}'
                        Restart-Service WinRM

                        # Configure TrustedHosts explicitly
                        Set-Item WSMan:\\localhost\\Client\\TrustedHosts -Value '*' -Force
                        Restart-Service WinRM
                    }
                """)

                if (result != 0) {
                    error "Failed to configure TrustedHosts & enable WinRM on ${ip}"
                }
            }
        }
    }
}


           stage('Execute Scripts on Windows VMs') {
    steps {
        script {
            def ipList = env.WINDOWS_IPS.split(',').findAll { it?.trim() }
            def tempPasswordFile = "decrypted_passwords.txt"

            // Read passwords from the temporary file
            def passwordMap = [:]
            if (fileExists(tempPasswordFile)) {
                def passwordContent = readFile(tempPasswordFile).trim()
                passwordMap = passwordContent.split('\n').collectEntries { line ->
                    def parts = line.split(':')
                    if (parts.size() == 2) {
                        [(parts[0]): parts[1]]
                    } else {
                        [:] // Ignore invalid entries
                    }
                }
            }

            for (ip in ipList) {
                if (!passwordMap.containsKey(ip)) {
                    echo "WARNING: Password for ${ip} not found! Skipping..."
                    continue
                }

                def password = passwordMap[ip]

                echo "Executing scripts on ${ip} using WinRM..."

                def result = powershell(returnStatus: true, script: """
                    \$username = 'Administrator'
                    \$password = ConvertTo-SecureString '${password}' -AsPlainText -Force
                    \$cred = New-Object System.Management.Automation.PSCredential (\$username, \$password)

                    Invoke-Command -ComputerName ${ip} -Credential \$cred -ScriptBlock {
                        Copy-Item -Path .\\ConfigureRemotingForAnsible.ps1 -Destination C:\\Windows\\Temp\\ConfigureRemotingForAnsible.ps1 -Force
                        Copy-Item -Path .\\Create_user.ps1 -Destination C:\\Windows\\Temp\\Create_user.ps1 -Force
                        
                        Write-Output "Executing ConfigureRemotingForAnsible.ps1..."
                        & C:\\Windows\\Temp\\ConfigureRemotingForAnsible.ps1

                        Write-Output "Executing Create_user.ps1..."
                        & C:\\Windows\\Temp\\Create_user.ps1
                    }
                """)

                if (result != 0) {
                    error "Execution failed on ${ip}"
                }

                echo "Scripts executed successfully on ${ip}!"
            }
        }
    }

                }
            }

            post {
                failure {
                    echo "Pipeline failed! Check logs for details."
                }
            }
        }